# -*- coding: utf-8 -*-
"""sde_1d_v02

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lFUGkiPyfB0-0yVt1DOGKvuiolHZ9pNM
"""

# In[1]:


import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as ss
from contract_v01 import VanillaOption
# In[2]:


'''=========
sde class init
=========='''

class Sde_1d:
    def __init__(self,
                init_state = 0.,
                drift = lambda x: 0,
                vol = lambda x: 1.
                ):
        self.init_state = init_state
        self.drift = drift
        self.vol = vol
        




'''============
Gbm class inherited from sde_1d
============='''

class Gbm_1d(Sde_1d):
    def __init__(self,
                 init_state = 100.,
                 drift_ratio = .0475,
                 vol_ratio = .2
                ):
        self.init_state = init_state
        
        self.drift_ratio = drift_ratio
        self.vol_ratio = vol_ratio
        
        self.drift = lambda x: drift_ratio*x
        self.vol = lambda x: vol_ratio*x


'''========
Black-Scholes-Merton formula. 
=========='''

def bsm_price(self, vanilla_option):
    s0 = self.init_state
    sigma = self.vol_ratio
    r = self.drift_ratio
    
    otype = vanilla_option.otype
    k = vanilla_option.strike
    maturity = vanilla_option.maturity
    
    d1 = (np.log(s0 / k) + (r + 0.5 * sigma ** 2) 
          * maturity) / (sigma * np.sqrt(maturity))
    d2 = d1 - sigma * np.sqrt(maturity)
    
    return (otype * s0 * ss.norm.cdf(otype * d1) #line break needs parenthesis
            - otype * np.exp(-r * maturity) * k * ss.norm.cdf(otype * d2))

Gbm_1d.bsm_price = bsm_price        



'''==============
output: BSM geometric asian option price
==============='''

def bsm_geometric_asian_price(self,
                             otype = 1,
                             strike = 110,
                             maturity = 1,
                             num_step = 4 #partition number
                             ):
  s0 = self.init_state
  sigma = self.vol_ratio
  r = self.drift_ratio
  n = num_step
  
  #NOTE: This price assumes a uniform partition time steps, for ease of coding.
 
  #Compute mu-hat
  #mu-hat = mu/2 (we are assuming uniform partition as stated above)
  mu = r - 0.5*(sigma**2)
  mu_hat = (mu/2)
  
  #Compute sigma-hat
  #Sigma-hat^2 = (sigma^2 * (2m + 1))/(6*(m+1)) where m is the number of steps.
  #Recall that the vol_ratio is sigma, not sigma^2. Thus we need both.
  sigma_hat_squared = ((sigma**2)*((2*n) + 1))/(6*(n+1))
  sigma_hat = sigma_hat_squared ** 0.5
  
  #With mu-hat and sigma-hat calculated, we can find r-hat.
  r_hat = mu_hat + (0.5 * sigma_hat_squared)
  
  #Create a separate GBM variable to store the new sigma and r, for the sake of
  #computing the price.
  
  gao_internal_gbm = Gbm_1d(init_state=s0,drift_ratio = r_hat,vol_ratio = sigma_hat)
  
  return np.exp((r_hat - r)*maturity) * gao_internal_gbm.bsm_price(VanillaOption(otype,strike,maturity))

Gbm_1d.bsm_geometric_asian_price = bsm_geometric_asian_price



'''==============
output: BSM arithmetic asian option price by exact sampling
==============='''
def bsm_arithmetic_asian_exact_sample(self,
                                     otype = 1,
                                     strike = 110,
                                     maturity = 1,
                                     num_step = 5,
                                     num_path = 100):
  s0 = self.init_state
  sigma = self.vol_ratio
  r = self.drift_ratio
  n = num_step
  m = num_path
  
  Stock_history = np.zeros((num_path,n+1))
  Stock_history[:,0] = s0;
  
  A = np.zeros(num_path)
  C_sample = np.zeros(num_path)
  
  # Generate (num_path) many GBM paths by exact sampling.
  
  for i in range(m):
    [t,W] = BM_gen(0,maturity,n)
    for j in range(n):
      Stock_history[i,j+1] = s0 * np.exp((r-(0.5*(sigma**2)))*t[j+1] + sigma*W[j+1])
    # Compute discounted payoff for each path.
    A[i] = np.mean(Stock_history[i,:])
    if A[i] - strike > 0:
      C_sample[i] = np.exp(-1*r*maturity) * (A[i]-strike)
    else:
      C_sample[i] = 0

  # Take average to find option price. For better results, take average of averages.
  return np.mean(C_sample)

Gbm_1d.bsm_arithmetic_asian_exact_sample = bsm_arithmetic_asian_exact_sample




# In[5]:

if __name__ == '__main__':       

        
            
    '''===============
    Test bsm_price
    ================='''
    gbm1 = Gbm_1d(init_state=100., drift_ratio=.0475, vol_ratio=.2)
    option1 = VanillaOption(otype = 1, strike = 110., maturity= 1., market_price=15.) 
    
    print('>>>>>>>>>>call value is ' + str(gbm1.bsm_price(option1)))
    option2 = VanillaOption(otype=-1)
    print('>>>>>>>>>>put value is ' + str(gbm1.bsm_price(option2)))